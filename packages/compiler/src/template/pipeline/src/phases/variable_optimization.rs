//! Variable Optimization Phase
//!
//! Corresponds to packages/compiler/src/template/pipeline/src/phases/variable_optimization.ts
//! Optimize variables declared and used in the IR.

use crate::output::output_ast::{Expression, Statement};
use crate::template::pipeline::ir;
use crate::template::pipeline::ir::enums::{OpKind, CompatibilityMode, VariableFlags, SemanticVariableKind};
use crate::template::pipeline::ir::expression::{is_ir_expression, as_ir_expression, transform_expressions_in_op, visit_expressions_in_op, VisitorContextFlag};
use crate::template::pipeline::ir::handle::XrefId;
use crate::template::pipeline::ir::ops::shared::{VariableOp, create_statement_op};
use crate::template::pipeline::ir::operations::OpList;
use crate::template::pipeline::src::compilation::{CompilationJob, CompilationUnit};
use std::collections::{HashMap, HashSet};
use indexmap::IndexMap;
use bitflags::bitflags;

bitflags! {
    /// A [fence](https://en.wikipedia.org/wiki/Memory_barrier) flag for an expression which indicates
    /// how that expression can be optimized in relation to other expressions or instructions.
    ///
    /// `Fence`s are a bitfield, so multiple flags may be set on a single expression.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct Fence: u8 {
        /// Empty flag (no fence exists).
        const NONE = 0b000;

        /// A context read fence, meaning that the expression in question reads from the "current view"
        /// context of the runtime.
        const VIEW_CONTEXT_READ = 0b001;

        /// A context write fence, meaning that the expression in question writes to the "current view"
        /// context of the runtime.
        ///
        /// Note that all `ContextWrite` fences are implicitly `ContextRead` fences as operations which
        /// change the view context do so based on the current one.
        const VIEW_CONTEXT_WRITE = 0b010;

        /// Indicates that a call is required for its side-effects, even if nothing reads its result.
        ///
        /// This is also true of `ViewContextWrite` operations **if** they are followed by a
        /// `ViewContextRead`.
        const SIDE_EFFECTFUL = 0b100;
    }
}

/// Summary data collected for each `Op` in a list.
///
/// Tracking this data per operation allows the optimizer to process operations at a higher level
/// than always scanning expressions.
#[derive(Clone)]
struct OpInfo {
    /// A set of variables referenced by expressions in this operation.
    variables_used: HashSet<XrefId>,

    /// Flags indicating any `Fence`s present for this operation.
    fences: Fence,
}

/// Optimize variables declared and used in the IR.
///
/// Variables are eagerly generated by pipeline stages for all possible values that could be
/// referenced. This stage processes the list of declared variables and all variable usages,
/// and optimizes where possible. It performs 3 main optimizations:
///
///   * It transforms variable declarations to side effectful expressions when the
///     variable is not used, but its initializer has global effects which other
///     operations rely upon.
///   * It removes variable declarations if those variables are not referenced and
///     either they do not have global effects, or nothing relies on them.
///   * It inlines variable declarations when those variables are only used once
///     and the inlining is semantically safe.
///
/// To guarantee correctness, analysis of "fences" in the instruction lists is used to determine
/// which optimizations are safe to perform.
pub fn optimize_variables(job: &mut dyn CompilationJob) {
    // Process all units (root and views)
    // No unsafe block needed - borrow checker handles this fine with proper scopes
    
    let component_job = job.as_any_mut().downcast_mut::<crate::template::pipeline::src::compilation::ComponentCompilationJob>()
        .expect("optimize_variables requires ComponentCompilationJob");
    
    let compatibility = component_job.compatibility;
    
    // Process root
    inline_always_inline_variables_create(component_job.root.create_mut());
    inline_always_inline_variables_update(component_job.root.update_mut());
    
    // Process handler ops in root create (using safe approach)
    // We collect indices or iterate mutably. Since process_handler_ops_create takes &mut op,
    // we can iterate.
    for op in component_job.root.create_mut().iter_mut() {
        process_handler_ops_create(op, |handler_ops| {
            inline_always_inline_variables_update(handler_ops);
        });
    }
    
    optimize_variables_in_op_list_create(component_job.root.create_mut(), compatibility);
    optimize_variables_in_op_list_update(component_job.root.update_mut(), compatibility);
    
    for op in component_job.root.create_mut().iter_mut() {
        process_handler_ops_create(op, |handler_ops| {
            optimize_variables_in_op_list_update(handler_ops, compatibility);
        });
    }
    
    // Process views
    for view in component_job.views.values_mut() {
        inline_always_inline_variables_create(view.create_mut());
        inline_always_inline_variables_update(view.update_mut());
        
        for op in view.create_mut().iter_mut() {
            process_handler_ops_create(op, |handler_ops| {
                inline_always_inline_variables_update(handler_ops);
            });
        }
        
        optimize_variables_in_op_list_create(view.create_mut(), compatibility);
        optimize_variables_in_op_list_update(view.update_mut(), compatibility);
        
        for op in view.create_mut().iter_mut() {
            process_handler_ops_create(op, |handler_ops| {
                optimize_variables_in_op_list_update(handler_ops, compatibility);
            });
        }
    }
}


/// Helper to process handler ops in a create operation
fn process_handler_ops_create<F>(op: &mut Box<dyn ir::CreateOp + Send + Sync>, mut f: F)
where
    F: FnMut(&mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>),
{
    use crate::template::pipeline::ir::ops::create::{ListenerOp, AnimationListenerOp, TwoWayListenerOp, RepeaterCreateOp};
    
    // Safe downcasting using as_any_mut()
    if let Some(listener) = op.as_any_mut().downcast_mut::<ListenerOp>() {
        f(&mut listener.handler_ops);
    } else if let Some(anim_listener) = op.as_any_mut().downcast_mut::<AnimationListenerOp>() {
        f(&mut anim_listener.handler_ops);
    } else if let Some(two_way) = op.as_any_mut().downcast_mut::<TwoWayListenerOp>() {
        f(&mut two_way.handler_ops);
    } else if let Some(repeater) = op.as_any_mut().downcast_mut::<RepeaterCreateOp>() {
        if let Some(ref mut track_by_ops) = repeater.track_by_ops {
            f(track_by_ops);
        }
    }
}

/// Inline variables marked with AlwaysInline flag for CreateOp list.
fn inline_always_inline_variables_create(ops: &mut OpList<Box<dyn ir::CreateOp + Send + Sync>>) {
    inline_always_inline_variables_impl_create(ops);
}

/// Inline variables marked with AlwaysInline flag for UpdateOp list.
fn inline_always_inline_variables_update(ops: &mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>) {
    inline_always_inline_variables_impl_update(ops);
}

/// Implementation for CreateOp list
fn inline_always_inline_variables_impl_create(ops: &mut OpList<Box<dyn ir::CreateOp + Send + Sync>>) {
    let mut vars: IndexMap<XrefId, usize> = IndexMap::new(); // xref -> index
    
    // First pass: collect AlwaysInline variables
    for (index, op) in ops.iter_mut().enumerate() {
        if op.kind() == OpKind::Variable {
            // Safe downcast and extract info to avoid borrow conflict
            let info = if let Some(var_op) = op.as_any().downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>() {
                Some((var_op.xref, var_op.flags))
            } else {
                None
            };

            if let Some((xref, flags)) = info {
                if flags.contains(VariableFlags::ALWAYS_INLINE) {
                     // Check context sensitivity
                     visit_expressions_in_op(
                        op.as_mut(),
                        &mut |expr: &Expression, _flags| {
                            if is_ir_expression(expr) {
                                if let Some(ir_expr) = as_ir_expression(expr) {
                                    if fences_for_ir_expression(&ir_expr) != Fence::NONE {
                                        panic!("AssertionError: A context-sensitive variable was marked AlwaysInline");
                                    }
                                }
                            }
                        },
                    );
                    vars.insert(xref, index);
                }
            }
        }
    }
    
    // Collect initializers
    let mut initializers: IndexMap<XrefId, Expression> = IndexMap::new();
    // We can't iterate ops again while modifying or borrowing.
    // Iterating ops is fine if we just read.
    for index in vars.values() {
        let op = ops.get(*index).unwrap();
        if let Some(var_op) = op.as_any().downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>() {
            initializers.insert(var_op.xref, (*var_op.initializer).clone());
        }
    }
    
    // Second pass: inline the variables
    for op in ops.iter_mut() {
        transform_expressions_in_op(
            op.as_mut(),
            &mut |expr: Expression, _flags| {
                if is_ir_expression(&expr) {
                    if let Some(ir_expr) = as_ir_expression(&expr) {
                        if let ir::IRExpression::ReadVariable(read_var) = ir_expr {
                            if let Some(initializer) = initializers.get(&read_var.xref) {
                                return initializer.clone();
                            }
                        }
                    }
                }
                expr
            },
            VisitorContextFlag::NONE,
        );
    }
    
    // Third pass: remove the AlwaysInline variable declarations
    let mut indices_to_remove: Vec<usize> = vars.values().copied().collect();
    indices_to_remove.sort();
    indices_to_remove.reverse();
    
    for &index in &indices_to_remove {
        ops.remove_at(index);
    }
}

/// Implementation for UpdateOp list
fn inline_always_inline_variables_impl_update(ops: &mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>) {
    let mut vars: IndexMap<XrefId, usize> = IndexMap::new(); 
    
    // First pass: collect AlwaysInline variables
    for (index, op) in ops.iter_mut().enumerate() {
        if op.kind() == OpKind::Variable {
            let info = if let Some(var_op) = op.as_any().downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>() {
                Some((var_op.xref, var_op.flags))
            } else {
                None
            };
            
            if let Some((xref, flags)) = info {
                if flags.contains(VariableFlags::ALWAYS_INLINE) {
                     visit_expressions_in_op(
                        op.as_mut(),
                        &mut |expr: &Expression, _flags| {
                            if is_ir_expression(expr) {
                                if let Some(ir_expr) = as_ir_expression(expr) {
                                    if fences_for_ir_expression(&ir_expr) != Fence::NONE {
                                        panic!("AssertionError: A context-sensitive variable was marked AlwaysInline");
                                    }
                                }
                            }
                        },
                    );
                    vars.insert(xref, index);
                }
            }
        }
    }
    
    // Collect initializers
    let mut initializers: IndexMap<XrefId, Expression> = IndexMap::new();
    for index in vars.values() {
        let op = ops.get(*index).unwrap();
        if let Some(var_op) = op.as_any().downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>() {
            initializers.insert(var_op.xref, (*var_op.initializer).clone());
        }
    }
    
    // Second pass: inline the variables
    for op in ops.iter_mut() {
        transform_expressions_in_op(
            op.as_mut(),
            &mut |expr: Expression, _flags| {
                if is_ir_expression(&expr) {
                    if let Some(ir_expr) = as_ir_expression(&expr) {
                        if let ir::IRExpression::ReadVariable(read_var) = ir_expr {
                            if let Some(initializer) = initializers.get(&read_var.xref) {
                                return initializer.clone();
                            }
                        }
                    }
                }
                expr
            },
            VisitorContextFlag::NONE,
        );
    }
    
    // Third pass: remove the AlwaysInline variable declarations
    let mut indices_to_remove: Vec<usize> = vars.values().copied().collect();
    indices_to_remove.sort();
    indices_to_remove.reverse();
    
    for &index in &indices_to_remove {
        ops.remove_at(index);
    }
}

/// Process a list of create operations and optimize variables within that list.
fn optimize_variables_in_op_list_create(
    ops: &mut OpList<Box<dyn ir::CreateOp + Send + Sync>>,
    compatibility: CompatibilityMode,
) {
    optimize_variables_in_op_list_impl_create(ops, compatibility);
}

/// Process a list of update operations and optimize variables within that list.
fn optimize_variables_in_op_list_update(
    ops: &mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>,
    compatibility: CompatibilityMode,
) {
    optimize_variables_in_op_list_impl_update(ops, compatibility);
}

/// Implementation for CreateOp list (Safe duplication of logic)
fn optimize_variables_in_op_list_impl_create(
    ops: &mut OpList<Box<dyn ir::CreateOp + Send + Sync>>,
    compatibility: CompatibilityMode,
) {
     let mut var_decls: IndexMap<XrefId, usize> = IndexMap::new(); 
    let mut var_usages: IndexMap<XrefId, usize> = IndexMap::new(); 
    let mut var_remote_usages: HashSet<XrefId> = HashSet::new();
    let mut op_map: IndexMap<usize, OpInfo> = IndexMap::new(); 
    
    // First pass
    for (index, op) in ops.iter().enumerate() {
        if op.kind() == OpKind::Variable {
            if let Some(var_op) = op.as_any().downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>() {
                if var_decls.contains_key(&var_op.xref) || var_usages.contains_key(&var_op.xref) {
                    panic!("Should not see two declarations of the same variable: {}", var_op.xref.as_usize());
                }
                var_decls.insert(var_op.xref, index);
                var_usages.insert(var_op.xref, 0);
            }
        }
        
        op_map.insert(index, collect_op_info(op.as_ref()));
        count_variable_usages(op.as_ref(), &mut var_usages, &mut var_remote_usages);
    }
    
    // Second pass
    let mut context_is_used = false;
    let mut indices_to_remove: Vec<usize> = Vec::new();
    let mut indices_to_replace: Vec<(usize, Statement)> = Vec::new(); 
    
    for index in (0..ops.len()).rev() {
        let op = ops.get(index).unwrap();
        
        if op.kind() == OpKind::Variable {
            if let Some(var_op) = op.as_any().downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>() {
                let usage_count = var_usages.get(&var_op.xref).copied().unwrap_or(0);
                
                if usage_count == 0 {
                    let op_info = op_map.get(&index).unwrap();
                    if (context_is_used && op_info.fences.contains(Fence::VIEW_CONTEXT_WRITE))
                        || op_info.fences.contains(Fence::SIDE_EFFECTFUL)
                    {
                        let stmt = (*var_op.initializer).clone().to_stmt();
                        indices_to_replace.push((index, stmt));
                    } else {
                        indices_to_remove.push(index);
                        uncount_variable_usages(op.as_ref(), &mut var_usages);
                    }
                    op_map.swap_remove(&index); // Use swap_remove for O(1), order doesn't matter for removal by index here? actually maps by index, so we remove key. IndexMap remove is O(n), Swap remove is O(1) but changes order.
                    // Actually since we rebuild op_map below, maybe it does not matter explicitly but lets stick to shift_remove (O(n)) to be safe or just remove.
                    // IndexMap::remove preserves order.
                    // op_map.remove(&index);
                    
                    var_decls.shift_remove(&var_op.xref);
                    var_usages.shift_remove(&var_op.xref);
                    continue;
                }
            }
        }
        
        if let Some(op_info) = op_map.get(&index) {
            if op_info.fences.contains(Fence::VIEW_CONTEXT_READ) {
                context_is_used = true;
            }
        }
    }
    
    for (index, stmt) in indices_to_replace {
        let stmt_op = create_statement_op::<Box<dyn ir::CreateOp + Send + Sync>>(Box::new(stmt));
        let op_info = op_map.shift_remove(&index).unwrap();
        ops.replace_at(index, Box::new(stmt_op));
        op_map.insert(index, op_info);
        // Restoring order might be tricky if we want index-based map ordered.
        // Actually op_map keys are indices.
        // The original logic rebuilt op_map entirely after removals.
    }
    
    for &index in indices_to_remove.iter() {
        ops.remove_at(index);
        let mut new_op_map = IndexMap::new();
        for (old_idx, info) in op_map {
            if old_idx > index {
                new_op_map.insert(old_idx - 1, info);
            } else if old_idx != index {
                new_op_map.insert(old_idx, info);
            }
        }
        op_map = new_op_map;
    }
    
    // Third pass
    let mut to_inline: Vec<XrefId> = Vec::new();
    for (xref, &count) in &var_usages {
        let &decl_index = var_decls.get(xref).unwrap();
        let decl_op = ops.get(decl_index).unwrap();
        
        if let Some(var_op) = decl_op.as_any().downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>() {
             let is_always_inline = var_op.flags.contains(VariableFlags::ALWAYS_INLINE);
             if count != 1 || is_always_inline { continue; }
             if var_remote_usages.contains(xref) { continue; }
             to_inline.push(*xref);
        }
    }
    
    while let Some(candidate) = to_inline.pop() {
        let decl_index = *var_decls.get(&candidate).unwrap();
        let decl_op = ops.get(decl_index).unwrap();
        
        // We need fields from var_op. Since we can't look it up after starting mutation loop,
        // we'll clone needed data: initializer, fencesOfVar(implied by info), allow_conservative check
        
        // But wait, to inline we need `try_inline_variable_initializer` which modifies target op.
        // And we need declaration op properties.
        // We can look up declaration op (read only) via index from ops.
        // Then get mutable reference to target op.
        // Rust allow multiple immutable borrows (via index) but if we have mutable borrow to ops...
        // `ops.get_mut(target_index)` borrows `ops`. We cannot then call `ops.get(decl_index)`.
        
        // Solution: Clone the initializer and relevant data from decl_op BEFORE getting target_op mutable.
        
        let (initializer, is_always_inline, var_kind) = {
             let op = ops.get(decl_index).unwrap();
             if let Some(var_op) = op.as_any().downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>() {
                 ((*var_op.initializer).clone(), var_op.flags.contains(VariableFlags::ALWAYS_INLINE), var_op.variable.kind())
             } else {
                 panic!("Expected VariableOp");
             }
        };
        
        if is_always_inline {
             panic!("AssertionError: Found an 'AlwaysInline' variable after the always inlining pass.");
        }
        
        let var_info = op_map.get(&decl_index).unwrap().clone();
        
        let mut inlined = false;
        
        // Iterate usage sites. We can't iterate ops mutably and keep indices easily if we insert/remove.
        // But here we are just modifying expressions inside ops.
        for target_index in (decl_index + 1)..ops.len() {
             let target_info_ref = op_map.get(&target_index).unwrap();
             if target_info_ref.variables_used.contains(&candidate) {
                 // Check conservative using safe check (requires cloning logic of allow_conservative_inlining or implementing it safely)
                 let mut allowed = true;
                 if compatibility == CompatibilityMode::TemplateDefinitionBuilder {
                      let target_op = ops.get(target_index).unwrap(); // Immutable borrow
                      // We need to implement allow_conservative_inlining taking params, not refs?
                      // We can pass initializer and target op.
                      if !allow_conservative_inlining(&initializer, target_op.as_ref(), var_kind) {
                          allowed = false;
                      }
                 }
                 if !allowed { break; }
                 
                 // Try inline
                 let target_op_mut = ops.get_mut(target_index).unwrap(); // Mutable borrow
                 if try_inline_variable_initializer(
                     candidate,
                     initializer.clone(),
                     target_op_mut.as_mut(),
                     var_info.fences.clone(),
                 ) {
                     let mut new_target_info = OpInfo {
                        variables_used: target_info_ref.variables_used.clone(),
                        fences: target_info_ref.fences,
                    };
                    new_target_info.variables_used.remove(&candidate);
                    for &var_xref in &var_info.variables_used {
                        new_target_info.variables_used.insert(var_xref);
                    }
                    new_target_info.fences |= var_info.fences.clone();
                    op_map.insert(target_index, new_target_info);
                    
                    var_decls.swap_remove(&candidate);
                    var_usages.swap_remove(&candidate);
                    
                    op_map.shift_remove(&decl_index);
                    ops.remove_at(decl_index);
                    
                    let mut new_op_map = IndexMap::new();
                    for (old_idx, info) in op_map {
                        if old_idx > decl_index {
                            new_op_map.insert(old_idx - 1, info);
                        } else if old_idx != decl_index {
                            new_op_map.insert(old_idx, info);
                        }
                    }
                    op_map = new_op_map;
                    
                    for index_ref in var_decls.values_mut() {
                        if *index_ref > decl_index {
                            *index_ref -= 1;
                        }
                    }

                    inlined = true;
                    break;
                 } else {
                     break;
                 }
             }
             
             if !safe_to_inline_past_fences(target_info_ref.fences, var_info.fences) {
                 break;
             }
        }
    }
}

/// Implementation for UpdateOp list (Safe duplication)
fn optimize_variables_in_op_list_impl_update(
    ops: &mut OpList<Box<dyn ir::UpdateOp + Send + Sync>>,
    compatibility: CompatibilityMode,
) {
    let mut var_decls: IndexMap<XrefId, usize> = IndexMap::new(); 
    let mut var_usages: IndexMap<XrefId, usize> = IndexMap::new(); 
    let mut var_remote_usages: HashSet<XrefId> = HashSet::new();
    let mut op_map: IndexMap<usize, OpInfo> = IndexMap::new(); 
    
    // First pass
    for (index, op) in ops.iter().enumerate() {
        if op.kind() == OpKind::Variable {
            if let Some(var_op) = op.as_any().downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>() {
                if var_decls.contains_key(&var_op.xref) || var_usages.contains_key(&var_op.xref) {
                    panic!("Should not see two declarations of the same variable: {}", var_op.xref.as_usize());
                }
                var_decls.insert(var_op.xref, index);
                var_usages.insert(var_op.xref, 0);
            }
        }
        
        op_map.insert(index, collect_op_info(op.as_ref()));
        count_variable_usages(op.as_ref(), &mut var_usages, &mut var_remote_usages);
    }
    
    // Second pass
    let mut context_is_used = false;
    let mut indices_to_remove: Vec<usize> = Vec::new();
    let mut indices_to_replace: Vec<(usize, Statement)> = Vec::new(); 
    
    for index in (0..ops.len()).rev() {
        let op = ops.get(index).unwrap();
        
        if op.kind() == OpKind::Variable {
            if let Some(var_op) = op.as_any().downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>() {
                let usage_count = var_usages.get(&var_op.xref).copied().unwrap_or(0);
                
                if usage_count == 0 {
                    let op_info = op_map.get(&index).unwrap();
                    if (context_is_used && op_info.fences.contains(Fence::VIEW_CONTEXT_WRITE))
                        || op_info.fences.contains(Fence::SIDE_EFFECTFUL)
                    {
                        let stmt = (*var_op.initializer).clone().to_stmt();
                        indices_to_replace.push((index, stmt));
                    } else {
                        indices_to_remove.push(index);
                        uncount_variable_usages(op.as_ref(), &mut var_usages);
                    }
                    op_map.swap_remove(&index); // Use swap_remove for O(1)
                    var_decls.shift_remove(&var_op.xref); // We need to remove the declaration. IndexMap remove is O(n), Swap remove O(1). Order in var_decls might matter depending on next pass?
                    // Actually next pass iterates var_usages.
                    // Let's safe shift_remove for now.
                    
                    var_usages.shift_remove(&var_op.xref);
                    continue;
                }
            }
        }
        
        if let Some(op_info) = op_map.get(&index) {
            if op_info.fences.contains(Fence::VIEW_CONTEXT_READ) {
                context_is_used = true;
            }
        }
    }
    
    for (index, stmt) in indices_to_replace {
        let stmt_op = create_statement_op::<Box<dyn ir::UpdateOp + Send + Sync>>(Box::new(stmt));
        let op_info = op_map.shift_remove(&index).unwrap();
        ops.replace_at(index, Box::new(stmt_op));
        op_map.insert(index, op_info);
    }
    
    for &index in indices_to_remove.iter() {
        ops.remove_at(index);
        let mut new_op_map = IndexMap::new();
        for (old_idx, info) in op_map {
            if old_idx > index {
                new_op_map.insert(old_idx - 1, info);
            } else if old_idx != index {
                new_op_map.insert(old_idx, info);
            }
        }
        op_map = new_op_map;
    }
    
    // Third pass
    let mut to_inline: Vec<XrefId> = Vec::new();
    // Explicitly iterate in insertion order because vars_usages is now an IndexMap
    for (xref, &count) in &var_usages {
        let &decl_index = var_decls.get(xref).unwrap();
        let decl_op = ops.get(decl_index).unwrap();
        
        if let Some(var_op) = decl_op.as_any().downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>() {
             let is_always_inline = var_op.flags.contains(VariableFlags::ALWAYS_INLINE);
             if count != 1 || is_always_inline { continue; }
             if var_remote_usages.contains(xref) { continue; }
             to_inline.push(*xref);
        }
    }
    
    // We want to process in reverse order of declaration to avoid index invalidation problems when we remove things.
    // Since we iterate var_usages in insertion order (which usually roughly matches declaration order),
    // we should process to_inline in reverse.
    // Note: If we really want to be sure, we should likely sort by declaration index descending.
    // But since the user asked for IndexMap usage to fix non-determinism, let's just reverse the list.
    // Wait, the user said "indexMap to replace. should not sort because we will have many other properties later".
    // This implies relying on IndexMap's deterministic order is enough.
    // However, for correct removal without index invalidation, we generally want to remove from end to start.
    // Let's assume to_inline is roughly in declaration order. Reversing it processes last declared first.
    
    // Actually, let's reverse iteration or pop from back (which is effectively reverse).
    // to_inline is pushed in order of var_usages iteration.
    
    while let Some(candidate) = to_inline.pop() {
        let decl_index = *var_decls.get(&candidate).unwrap();
        
        let (initializer, is_always_inline, var_kind) = {
             let op = ops.get(decl_index).unwrap();
             if let Some(var_op) = op.as_any().downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>() {
                 ((*var_op.initializer).clone(), var_op.flags.contains(VariableFlags::ALWAYS_INLINE), var_op.variable.kind())
             } else {
                 panic!("Expected VariableOp");
             }
        };
        
        if is_always_inline {
             panic!("AssertionError: Found an 'AlwaysInline' variable after the always inlining pass.");
        }
        
        let var_info = op_map.get(&decl_index).unwrap().clone();
        let mut inlined = false;
        
        for target_index in (decl_index + 1)..ops.len() {
             let target_info_ref = op_map.get(&target_index).unwrap();
             if target_info_ref.variables_used.contains(&candidate) {
                 let mut allowed = true;
                 if compatibility == CompatibilityMode::TemplateDefinitionBuilder {
                      let target_op = ops.get(target_index).unwrap(); 
                      if !allow_conservative_inlining(&initializer, target_op.as_ref(), var_kind) {
                          allowed = false;
                      }
                 }
                 if !allowed { break; }
                 
                 let target_op_mut = ops.get_mut(target_index).unwrap(); 
                 if try_inline_variable_initializer(
                     candidate,
                     initializer.clone(),
                     target_op_mut.as_mut(),
                     var_info.fences.clone(),
                 ) {
                    let mut new_target_info = OpInfo {
                        variables_used: target_info_ref.variables_used.clone(),
                        fences: target_info_ref.fences,
                    };
                    new_target_info.variables_used.remove(&candidate);
                    for &var_xref in &var_info.variables_used {
                        new_target_info.variables_used.insert(var_xref);
                    }
                    new_target_info.fences |= var_info.fences.clone();
                    op_map.insert(target_index, new_target_info);
                    
                    var_decls.swap_remove(&candidate); // O(1) removal
                    var_usages.swap_remove(&candidate);
                    
                    op_map.shift_remove(&decl_index); // This shifts indices!
                    // This is problematic. If we shift remove, all indices > decl_index inside op_map and var_decls become invalid.
                    // This is why invalidation happens.
                    // The original code rebuilt op_map.
                    
                    ops.remove_at(decl_index);
                    
                    let mut new_op_map = IndexMap::new();
                    // We need to shift keys in op_map > decl_index down by 1.
                    // Since op_map is IndexMap<usize, OpInfo>, we can iterate and rebuild.
                    for (old_idx, info) in op_map {
                        if old_idx > decl_index {
                            new_op_map.insert(old_idx - 1, info);
                        } else if old_idx != decl_index { // Should not happen as we removed it
                            new_op_map.insert(old_idx, info);
                        }
                    }
                    op_map = new_op_map;
                    
                    // We also need to update indices in var_decls!
                    // The original code didn't do this?! 
                    // Wait, original code:
                    // `var_decls.remove(&candidate);`
                    // `op_map = new_op_map;`
                    // It seems the original code also had this bug or `var_decls` were not used again for indices?
                    // Ah, `decl_index` is looked up from `var_decls` at the start of loop.
                    // If we don't update `var_decls`, subsequent lookups for other variables might point to wrong indices if they shifted?
                    // Only if they were declared AFTER the removed variable.
                    // If we process in reverse order (to_inline.pop()), we process variables with higher indices first?
                    // No, `to_inline` order depends on `var_usages` iteration order.
                    // If we iterate insertion order, we might get any order.
                    // But popping gives reverse.
                    
                    // The user said "should not sort".
                    // But we MUST handle index invalidation.
                    // If we use `IndexMap`, validation is deterministic but logic still needs to be correct.
                    // I will add logic to update `var_decls` indices.
                    
                    for index_ref in var_decls.values_mut() {
                        if *index_ref > decl_index {
                            *index_ref -= 1;
                        }
                    }
                    
                    inlined = true;
                    break;
                 } else {
                     break;
                 }
             }
             
             if !safe_to_inline_past_fences(target_info_ref.fences, var_info.fences) {
                 break;
             }
        }
    }
}

/// Helper to visit expressions in an operation without needing mutable reference
/// Uses recursive pattern to traverse all expressions
fn visit_expressions_in_op_readonly(
    op: &dyn ir::Op,
    visitor: &mut dyn FnMut(&Expression, VisitorContextFlag),
    flags: VisitorContextFlag,
) {
    use crate::template::pipeline::ir::ops::update::*;
    use crate::template::pipeline::ir::ops::shared::*;
    use crate::template::pipeline::ir::ops::create::*;
    
    // helper to visit binding ops
    let mut visit_binding_op = |binding: &BindingOp, visitor: &mut dyn FnMut(&Expression, VisitorContextFlag), flags| {
        match &binding.expression {
            BindingExpression::Expression(expr) => visit_expressions_recursive(expr, visitor, flags),
            BindingExpression::Interpolation(interp) => {
                for expr in &interp.expressions {
                    visit_expressions_recursive(expr, visitor, flags);
                }
            }
        }
    };

    match op.kind() {
        OpKind::Variable => {
            if let Some(var_op) = op.as_any().downcast_ref::<VariableOp<Box<dyn ir::CreateOp + Send + Sync>>>() {
                visit_expressions_recursive(&var_op.initializer, visitor, flags);
            } else if let Some(var_op) = op.as_any().downcast_ref::<VariableOp<Box<dyn ir::UpdateOp + Send + Sync>>>() {
                visit_expressions_recursive(&var_op.initializer, visitor, flags);
            } else if let Some(var_op) = op.as_any().downcast_ref::<VariableOp<Box<dyn ir::Op + Send + Sync>>>() {
                // Fallback for when we don't know the exact type but it matches Op
                 visit_expressions_recursive(&var_op.initializer, visitor, flags);
            }
        }
        OpKind::Binding => {
            if let Some(binding) = op.as_any().downcast_ref::<BindingOp>() {
                visit_binding_op(binding, visitor, flags);
            }
        }
        OpKind::Property => {
            if let Some(prop) = op.as_any().downcast_ref::<PropertyOp>() {
                match &prop.expression {
                    BindingExpression::Expression(expr) => visit_expressions_recursive(expr, visitor, flags),
                    BindingExpression::Interpolation(interp) => {
                         for e in &interp.expressions { visit_expressions_recursive(e, visitor, flags); }
                    }
                }
                if let Some(ref s) = prop.sanitizer { visit_expressions_recursive(s, visitor, flags); }
            }
        }
        OpKind::DomProperty => {
             if let Some(p) = op.as_any().downcast_ref::<crate::template::pipeline::ir::ops::host::DomPropertyOp>() {
                 match &p.expression {
                    BindingExpression::Expression(expr) => visit_expressions_recursive(expr, visitor, flags),
                    BindingExpression::Interpolation(interp) => {
                         for e in &interp.expressions { visit_expressions_recursive(e, visitor, flags); }
                    }
                }
                if let Some(ref s) = p.sanitizer { visit_expressions_recursive(s, visitor, flags); }
             }
        }
        OpKind::Attribute => {
            if let Some(attr) = op.as_any().downcast_ref::<AttributeOp>() {
                 match &attr.expression {
                    BindingExpression::Expression(expr) => visit_expressions_recursive(expr, visitor, flags),
                    BindingExpression::Interpolation(interp) => {
                         for e in &interp.expressions { visit_expressions_recursive(e, visitor, flags); }
                    }
                }
                if let Some(ref s) = attr.sanitizer { visit_expressions_recursive(s, visitor, flags); }
            }
        }
        OpKind::Control => {
             if let Some(c) = op.as_any().downcast_ref::<ControlOp>() {
                 match &c.expression {
                    BindingExpression::Expression(expr) => visit_expressions_recursive(expr, visitor, flags),
                    BindingExpression::Interpolation(interp) => {
                         for e in &interp.expressions { visit_expressions_recursive(e, visitor, flags); }
                    }
                }
                if let Some(ref s) = c.sanitizer { visit_expressions_recursive(s, visitor, flags); }
             }
        }
        OpKind::StyleProp => {
            if let Some(p) = op.as_any().downcast_ref::<StylePropOp>() {
                 match &p.expression {
                    BindingExpression::Expression(expr) => visit_expressions_recursive(expr, visitor, flags),
                    BindingExpression::Interpolation(interp) => {
                         for e in &interp.expressions { visit_expressions_recursive(e, visitor, flags); }
                    }
                }
            }
        }
        OpKind::ClassProp => {
             if let Some(p) = op.as_any().downcast_ref::<ClassPropOp>() {
                 visit_expressions_recursive(&p.expression, visitor, flags);
             }
        }
        OpKind::StyleMap => {
             if let Some(p) = op.as_any().downcast_ref::<StyleMapOp>() {
                 match &p.expression {
                    BindingExpression::Expression(expr) => visit_expressions_recursive(expr, visitor, flags),
                    BindingExpression::Interpolation(interp) => {
                         for e in &interp.expressions { visit_expressions_recursive(e, visitor, flags); }
                    }
                }
             }
        }
        OpKind::ClassMap => {
             if let Some(p) = op.as_any().downcast_ref::<ClassMapOp>() {
                 match &p.expression {
                    BindingExpression::Expression(expr) => visit_expressions_recursive(expr, visitor, flags),
                    BindingExpression::Interpolation(interp) => {
                         for e in &interp.expressions { visit_expressions_recursive(e, visitor, flags); }
                    }
                }
             }
        }
        OpKind::InterpolateText => {
            if let Some(i) = op.as_any().downcast_ref::<InterpolateTextOp>() {
                 for e in &i.interpolation.expressions { visit_expressions_recursive(e, visitor, flags); }
            }
        }
        OpKind::Statement => {
            if let Some(stmt) = op.as_any().downcast_ref::<StatementOp<Box<dyn ir::UpdateOp + Send + Sync>>>() {
                 visit_expressions_in_statement(&stmt.statement, visitor, flags);
            } else if let Some(stmt) = op.as_any().downcast_ref::<StatementOp<Box<dyn ir::CreateOp + Send + Sync>>>() {
                 visit_expressions_in_statement(&stmt.statement, visitor, flags);
            }
        }
        OpKind::StoreLet => {
             if let Some(s) = op.as_any().downcast_ref::<StoreLetOp>() {
                 visit_expressions_recursive(&s.value, visitor, flags);
             }
        }
        OpKind::I18nExpression => {
             if let Some(i) = op.as_any().downcast_ref::<I18nExpressionOp>() {
                 visit_expressions_recursive(&i.expression, visitor, flags);
             }
        }
        OpKind::DeferWhen => {
             if let Some(d) = op.as_any().downcast_ref::<DeferWhenOp>() {
                 visit_expressions_recursive(&d.expr, visitor, flags);
             }
        }
        OpKind::AnimationString => {
             if let Some(a) = op.as_any().downcast_ref::<AnimationStringOp>() {
                 match &a.expression {
                    BindingExpression::Expression(expr) => visit_expressions_recursive(expr, visitor, flags),
                    BindingExpression::Interpolation(interp) => {
                         for e in &interp.expressions { visit_expressions_recursive(e, visitor, flags); }
                    }
                }
             }
        }
        OpKind::AnimationBinding => {
             if let Some(a) = op.as_any().downcast_ref::<AnimationBindingOp>() {
                 match &a.expression {
                    BindingExpression::Expression(expr) => visit_expressions_recursive(expr, visitor, flags),
                    BindingExpression::Interpolation(interp) => {
                         for e in &interp.expressions { visit_expressions_recursive(e, visitor, flags); }
                    }
                }
             }
        }
        OpKind::TwoWayProperty => {
             if let Some(t) = op.as_any().downcast_ref::<TwoWayPropertyOp>() {
                 visit_expressions_recursive(&t.expression, visitor, flags);
                 if let Some(ref s) = t.sanitizer { visit_expressions_recursive(s, visitor, flags); }
             }
        }
        OpKind::Conditional => {
             if let Some(c) = op.as_any().downcast_ref::<ConditionalOp>() {
                 if let Some(ref test) = c.test { visit_expressions_recursive(test, visitor, flags); }
                 for case in &c.conditions {
                     if let Some(ref expr) = case.expr { visit_expressions_recursive(expr, visitor, flags); }
                 }
                 if let Some(ref p) = c.processed { visit_expressions_recursive(p, visitor, flags); }
                 if let Some(ref v) = c.context_value { visit_expressions_recursive(v, visitor, flags); }
             }
        }
        OpKind::Repeater => {
             if let Some(r) = op.as_any().downcast_ref::<RepeaterOp>() {
                 visit_expressions_recursive(&r.collection, visitor, flags);
             }
        }
        _ => {}
    }
}

/// Recursively visit all expressions in an expression
fn visit_expressions_recursive(
    expr: &Expression,
    visitor: &mut dyn FnMut(&Expression, VisitorContextFlag),
    flags: VisitorContextFlag,
) {
    visitor(expr, flags);
    use crate::output::output_ast::Expression as OutputExpr;
    match expr {
        OutputExpr::BinaryOp(bin) => {
            visit_expressions_recursive(&bin.lhs, visitor, flags);
            visit_expressions_recursive(&bin.rhs, visitor, flags);
        }
        OutputExpr::Unary(un) => {
            visit_expressions_recursive(&un.expr, visitor, flags);
        }
        OutputExpr::ReadProp(prop) => {
            visit_expressions_recursive(&prop.receiver, visitor, flags);
        }
        OutputExpr::ReadKey(key) => {
            visit_expressions_recursive(&key.receiver, visitor, flags);
            visit_expressions_recursive(&key.index, visitor, flags);
        }
        OutputExpr::InvokeFn(invoke) => {
            visit_expressions_recursive(&invoke.fn_, visitor, flags);
            for arg in &invoke.args { visit_expressions_recursive(arg, visitor, flags); }
        }
        OutputExpr::LiteralArray(arr) => {
            for entry in &arr.entries { visit_expressions_recursive(entry, visitor, flags); }
        }
        OutputExpr::LiteralMap(map) => {
            for entry in &map.entries { visit_expressions_recursive(&entry.value, visitor, flags); }
        }
        OutputExpr::Conditional(cond) => {
            visit_expressions_recursive(&cond.condition, visitor, flags);
            visit_expressions_recursive(&cond.true_case, visitor, flags);
            if let Some(ref false_case) = cond.false_case {
                visit_expressions_recursive(false_case, visitor, flags);
            }
        }
        OutputExpr::SafePropertyRead(ir_expr) => {
            visit_expressions_recursive(&ir_expr.receiver, visitor, flags);
        }
        OutputExpr::SafeKeyedRead(ir_expr) => {
            visit_expressions_recursive(&ir_expr.receiver, visitor, flags);
            visit_expressions_recursive(&ir_expr.index, visitor, flags);
        }
        OutputExpr::SafeInvokeFunction(ir_expr) => {
            visit_expressions_recursive(&ir_expr.receiver, visitor, flags);
            for arg in &ir_expr.args { visit_expressions_recursive(arg, visitor, flags); }
        }
        OutputExpr::SafeTernary(ir_expr) => {
            visit_expressions_recursive(&ir_expr.guard, visitor, flags);
            visit_expressions_recursive(&ir_expr.expr, visitor, flags);
        }
        OutputExpr::PipeBinding(ir_expr) => {
            for arg in &ir_expr.args { visit_expressions_recursive(arg, visitor, flags); }
        }
        OutputExpr::PipeBindingVariadic(ir_expr) => {
            visit_expressions_recursive(&ir_expr.args, visitor, flags);
        }
        OutputExpr::AssignTemporary(ir_expr) => {
            visit_expressions_recursive(&ir_expr.expr, visitor, flags);
        }
        OutputExpr::StoreLet(ir_expr) => {
            visit_expressions_recursive(&ir_expr.value, visitor, flags);
        }
        OutputExpr::ConditionalCase(ir_expr) => {
            if let Some(ref expr) = ir_expr.expr { visit_expressions_recursive(expr, visitor, flags); }
        }
        _ => {}
    }
}

/// Visit expressions in a statement
fn visit_expressions_in_statement(
    stmt: &Statement,
    visitor: &mut dyn FnMut(&Expression, VisitorContextFlag),
    flags: VisitorContextFlag,
) {
    use crate::output::output_ast::Statement;
    match stmt {
        Statement::Expression(expr_stmt) => {
            visit_expressions_recursive(&expr_stmt.expr, visitor, flags);
        }
        Statement::Return(return_stmt) => {
            visit_expressions_recursive(&return_stmt.value, visitor, flags);
        }
        Statement::DeclareVar(declare_var) => {
            if let Some(ref value) = declare_var.value {
                visit_expressions_recursive(value, visitor, flags);
            }
        }
        Statement::IfStmt(if_stmt) => {
            visit_expressions_recursive(&if_stmt.condition, visitor, flags);
            for case_stmt in &if_stmt.true_case { visit_expressions_in_statement(case_stmt, visitor, flags); }
            for case_stmt in &if_stmt.false_case { visit_expressions_in_statement(case_stmt, visitor, flags); }
        }
        Statement::DeclareFn(declare_fn) => {
            for stmt in &declare_fn.statements { visit_expressions_in_statement(stmt, visitor, flags); }
        }
    }
}

/// Build the `OpInfo` structure for the given `op`.
fn collect_op_info(op: &dyn ir::Op) -> OpInfo {
    let mut fences = Fence::NONE;
    let mut variables_used = HashSet::new();
    
    // Use read-only visitor to collect info
    visit_expressions_in_op_readonly(
        op,
        &mut |expr: &Expression, _flags| {
            if is_ir_expression(expr) {
                if let Some(ir_expr) = as_ir_expression(expr) {
                    match ir_expr {
                        ir::IRExpression::ReadVariable(read_var) => {
                            variables_used.insert(read_var.xref);
                        }
                        _ => {
                            fences |= fences_for_ir_expression(&ir_expr);
                        }
                    }
                }
            }
        },
        VisitorContextFlag::NONE,
    );
    
    OpInfo {
        variables_used,
        fences,
    }
}

/// Count the number of usages of each variable, being careful to track whether those usages are
/// local or remote.
fn count_variable_usages(
    op: &dyn ir::Op,
    var_usages: &mut IndexMap<XrefId, usize>,
    var_remote_usage: &mut HashSet<XrefId>,
) {
    visit_expressions_in_op_readonly(
        op,
        &mut |expr: &Expression, flags| {
            if is_ir_expression(expr) {
                if let Some(ir_expr) = as_ir_expression(expr) {
                    if let ir::IRExpression::ReadVariable(read_var) = ir_expr {
                        if let Some(count) = var_usages.get_mut(&read_var.xref) {
                            *count += 1;
                            
                            if flags.contains(VisitorContextFlag::IN_CHILD_OPERATION) {
                                var_remote_usage.insert(read_var.xref);
                            }
                        }
                    }
                }
            }
        },
        VisitorContextFlag::NONE,
    );
}

/// Remove usages of a variable in `op` from the `var_usages` tracking.
fn uncount_variable_usages(
    op: &dyn ir::Op,
    var_usages: &mut IndexMap<XrefId, usize>,
) {
    visit_expressions_in_op_readonly(
        op,
        &mut |expr: &Expression, _flags| {
            if is_ir_expression(expr) {
                if let Some(ir_expr) = as_ir_expression(expr) {
                    if let ir::IRExpression::ReadVariable(read_var) = ir_expr {
                        if let Some(count) = var_usages.get_mut(&read_var.xref) {
                            if *count == 0 {
                                panic!(
                                    "Inaccurate variable count: {} - found another read but count is already 0",
                                    read_var.xref.as_usize()
                                );
                            }
                            *count -= 1;
                        }
                    }
                }
            }
        },
        VisitorContextFlag::NONE,
    );
}

/// Checks whether it's safe to inline a variable across a particular operation.
fn safe_to_inline_past_fences(fences: Fence, decl_fences: Fence) -> bool {
    if fences.contains(Fence::VIEW_CONTEXT_WRITE) {
        if decl_fences.contains(Fence::VIEW_CONTEXT_READ) {
            return false;
        }
    } else if fences.contains(Fence::VIEW_CONTEXT_READ) {
        if decl_fences.contains(Fence::VIEW_CONTEXT_WRITE) {
            return false;
        }
    }
    true
}

/// Attempt to inline the initializer of a variable into a target operation's expressions.
fn try_inline_variable_initializer(
    id: XrefId,
    initializer: Expression,
    target: &mut dyn ir::Op,
    decl_fences: Fence,
) -> bool {
    let mut inlined = false;
    let mut inlining_allowed = true;
    
    transform_expressions_in_op(
        target,
        &mut |expr: Expression, flags| {
            if inlined || !inlining_allowed {
                return expr;
            }
            
            if !is_ir_expression(&expr) {
                return expr;
            }
            
            if let Some(ir_expr) = as_ir_expression(&expr) {
                if flags.contains(VisitorContextFlag::IN_CHILD_OPERATION)
                    && decl_fences.contains(Fence::VIEW_CONTEXT_READ)
                {
                    // Cannot inline context-sensitive variables across operation boundaries
                    return expr;
                }
                
                match ir_expr {
                    ir::IRExpression::ReadVariable(read_var) => {
                        if read_var.xref == id {
                            // This is the usage site - inline it
                            inlined = true;
                            return initializer.clone();
                        }
                    }
                    _ => {
                        // Check fences for this expression
                        let expr_fences = fences_for_ir_expression(&ir_expr);
                        inlining_allowed = inlining_allowed && safe_to_inline_past_fences(expr_fences, decl_fences);
                    }
                }
            }
            
            expr
        },
        VisitorContextFlag::NONE,
    );
    
    inlined
}



/// Safe alternative to check conservative inlining without requiring generic VariableOp
/// Safe check for conservative inlining that matches TS logic
fn allow_conservative_inlining(
    initializer: &Expression,
    target: &dyn ir::Op,
    variable_kind: SemanticVariableKind,
) -> bool {
    match variable_kind {
        SemanticVariableKind::Identifier => {
            if let Expression::ReadVar(read_var) = initializer {
                if read_var.name == "ctx" {
                    return true;
                }
            }
            false
        }
        SemanticVariableKind::Context => {
            target.kind() == OpKind::Variable
        }
        _ => true
    }
}


/// Given an `ir.Expression`, returns the `Fence` flags for that expression type.
fn fences_for_ir_expression(expr: &ir::IRExpression) -> Fence {
    match expr {
        ir::IRExpression::NextContext(_) => {
            Fence::VIEW_CONTEXT_READ | Fence::VIEW_CONTEXT_WRITE
        }
        ir::IRExpression::RestoreView(_) => {
            Fence::VIEW_CONTEXT_READ | Fence::VIEW_CONTEXT_WRITE | Fence::SIDE_EFFECTFUL
        }
        ir::IRExpression::StoreLet(_) => {
            Fence::SIDE_EFFECTFUL
        }
        ir::IRExpression::Reference(_) | ir::IRExpression::ContextLetReference(_) => {
            Fence::VIEW_CONTEXT_READ
        }
        _ => Fence::NONE,
    }
}
